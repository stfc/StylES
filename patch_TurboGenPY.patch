diff --git a/example2d.py b/example2d.py
index 937c5c4..daf63b4 100644
--- a/example2d.py
+++ b/example2d.py
@@ -87,7 +87,7 @@ if m:
 	print(m)
 
 
-# specify which spectrum you want to use. Options are: cbc_spec, vkp_spec, and power_spec
+# specify which spectrum you want to use. Options are: cbc_spec, vkp_spec, power_spec and ld
 inputspec = 'cbc'
 if args.spectrum:
 	inputspec = args.spectrum
@@ -96,8 +96,8 @@ if args.spectrum:
 fileappend = inputspec + '_' + str(nx) + '.' + str(ny) + '_' + str(nmodes) + '_modes'
 
 print('input spec', inputspec)
-if inputspec != 'cbc' and inputspec != 'vkp' and inputspec != 'kcm':
-	print('Error: ', inputspec, ' is not a supported spectrum. Supported spectra are: cbc, vkp, and power. Please revise your input.')
+if inputspec != 'cbc' and inputspec != 'vkp' and inputspec != 'kcm' and inputspec != 'ld':
+	print('Error: ', inputspec, ' is not a supported spectrum. Supported spectra are: cbc, vkp, power and ld. Please revise your input.')
 	exit()
 inputspec += '_spectrum'
 # now given a string name of the spectrum, find the corresponding function with the same name. use locals() because spectrum functions are defined in this module.
@@ -144,7 +144,7 @@ dx = lx / nx
 dy = ly / ny
 
 t0 = time.time()
-u, v = isoturb.generate_isotropic_turbulence(lx, ly, nx, ny, nmodes, wn1, whichspec)
+u, v = isoturb.generate_isotropic_turbulence_2d(lx, ly, nx, ny, nmodes, wn1, whichspec)
 t1 = time.time()
 elapsed_time = t1 - t0
 print('it took me ', elapsed_time, 's to generate the isotropic turbulence.')
@@ -186,7 +186,7 @@ if computeMean:
 #     print('cells with divergence: ', count)
 
 # verify that the generated velocities fit the spectrum
-knyquist, wavenumbers, tkespec = compute_tke_spectrum2d_3v(u, v, lx, ly, False)
+knyquist, wavenumbers, tkespec = compute_tke_spectrum2d_3v(u, v, lx, ly, True)
 # save the generated spectrum to a text file for later post processing
 np.savetxt('tkespec_' + fileappend + '.txt', np.transpose([wavenumbers, tkespec]))
 
@@ -251,7 +251,7 @@ wnn = np.arange(wn1, 2000)
 l1, = plt.loglog(wnn, whichspec(wnn), 'k-', label='input')
 l2, = plt.loglog(wavenumbers[1:6], tkespec[1:6], 'bo--', markersize=3, markerfacecolor='w', markevery=1, label='computed')
 plt.loglog(wavenumbers[5:], tkespec[5:], 'bo--', markersize=3, markerfacecolor='w', markevery=4, label='computed')
-plt.axis([8, 10000, 1e-7, 1e-2])
+plt.axis([6.283, 6283, 1e-12, 1e-0])
 # plt.xticks(fontsize=12)
 # plt.yticks(fontsize=12)
 plt.axvline(x=knyquist, linestyle='--', color='black')
diff --git a/spectra.py b/spectra.py
index 23189d9..ce00273 100644
--- a/spectra.py
+++ b/spectra.py
@@ -91,3 +91,26 @@ class pq_spectrum:
     kke = k/ke
     espec = 16.0*uavg*uavg/ke * np.sqrt(2.0/np.pi) * pow(kke,4) * np.exp(-2.0*(kke)*(kke))
     return espec
+
+
+class ld_spectrum:
+  # # Implements the Lowe & Davidson spectrum (Re=240)
+  # def __init__(self):
+  #   # find max and min wave numbers
+  #   self.Q    = 1.0e-22
+  #   self.kp   = 100*2*np.pi
+
+  #   # find k and E
+  # def evaluate(self, k):
+  #   espec = self.Q*(k**8)*np.exp(-4*(k/self.kp)**2)
+  #   return espec
+
+  def __init__(self):
+    dalspec = np.loadtxt('testcases/HIT_2D/ld_spectrum_0te.txt')
+    kdal=dalspec[:,0]
+    edal=dalspec[:,1]
+    self.especf = interpolate.interp1d(kdal, edal,'linear', fill_value="extrapolate")
+    self.kmin = kdal[0]
+    self.kmax = kdal[len(kdal) - 1]
+  def evaluate(self,k):
+    return self.especf(k)
diff --git a/tkespec.py b/tkespec.py
index 76701e6..6296604 100644
--- a/tkespec.py
+++ b/tkespec.py
@@ -91,6 +91,13 @@ def compute_tke_spectrum_1d(u, lx, ly, lz, smooth):
 
     tke_spectrum = tke_spectrum / knorm
 
+    sumTke = 0.0e0
+    for k in range(nx-1):
+       sumTke = sumTke + tke_spectrum[k]*(wave_numbers[k+1] - wave_numbers[k])
+
+    print("Turbulent Kinetical energy is", sumTke)
+
+
     if smooth:
         tkespecsmooth = movingaverage(tke_spectrum, 5)  # smooth the spectrum
         tkespecsmooth[0:4] = tke_spectrum[0:4]  # get the first 4 values from the original data
@@ -246,7 +253,7 @@ def compute_tke_spectrum2d_3v(u, v, lx, ly, smooth):
     k0y = 2.0 * pi / ly
 
     knorm = (k0x + k0y) / 2.0
-    print('knorm = ', knorm)
+    #print('knorm = ', knorm)
 
     kxmax = nx / 2
     kymax = ny / 2
@@ -262,7 +269,7 @@ def compute_tke_spectrum2d_3v(u, v, lx, ly, smooth):
         for ky in range(-ny//2, ny//2-1):
         	rk = sqrt(kx**2 + ky**2)
         	k = int(np.round(rk))
-        	tke_spectrum[k] += tkeh[kx, ky]
+        	tke_spectrum[k] += tkeh[kx, ky].real
     tke_spectrum = tke_spectrum / knorm
 
     #  tke_spectrum = tke_spectrum[1:]
